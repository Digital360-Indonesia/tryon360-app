const fs = require('fs').promises;\nconst path = require('path');\n\n/**\n * MetricsTracking - Comprehensive performance monitoring and analytics service\n * Tracks generation metrics, costs, success rates, and user satisfaction\n */\nclass MetricsTracking {\n  constructor() {\n    this.metrics = {\n      generations: [],\n      dailyStats: {},\n      modelPerformance: {},\n      costTracking: {},\n      userFeedback: [],\n      systemPerformance: []\n    };\n    \n    this.metricsFile = path.join(__dirname, '../../data/metrics.json');\n    this.retentionDays = 90; // Keep metrics for 90 days\n    \n    // Load existing metrics\n    this.loadMetrics();\n    \n    // Start periodic cleanup\n    this.startPeriodicCleanup();\n  }\n\n  /**\n   * Track a generation attempt\n   * @param {Object} generationData - Generation attempt data\n   */\n  async trackGeneration(generationData) {\n    const {\n      jobId,\n      modelId,\n      pose,\n      qualityTier,\n      garmentType,\n      startTime,\n      endTime,\n      success,\n      attempts,\n      finalQuality,\n      validationResults,\n      cost,\n      errorType,\n      retryHistory,\n      parameters\n    } = generationData;\n    \n    const generation = {\n      id: jobId,\n      timestamp: Date.now(),\n      date: new Date().toISOString().split('T')[0],\n      modelId,\n      pose,\n      qualityTier,\n      garmentType: garmentType || 'unknown',\n      duration: endTime - startTime,\n      success,\n      attempts: attempts || 1,\n      finalQuality: finalQuality || 0,\n      cost: cost || 0,\n      errorType: errorType || null,\n      retryCount: retryHistory ? retryHistory.length : 0,\n      validation: validationResults ? {\n        overallQuality: validationResults.overallQuality,\n        consistency: validationResults.consistency?.overallScore || 0,\n        accuracy: validationResults.accuracy?.overallScore || 0,\n        passes: validationResults.passes\n      } : null,\n      parameters: parameters || {}\n    };\n    \n    this.metrics.generations.push(generation);\n    \n    // Update daily stats\n    this.updateDailyStats(generation);\n    \n    // Update model performance\n    this.updateModelPerformance(generation);\n    \n    // Update cost tracking\n    this.updateCostTracking(generation);\n    \n    // Save metrics\n    await this.saveMetrics();\n    \n    return generation.id;\n  }\n\n  /**\n   * Track user feedback\n   * @param {Object} feedbackData - User feedback data\n   */\n  async trackUserFeedback(feedbackData) {\n    const {\n      generationId,\n      userId,\n      rating,\n      feedback,\n      categories,\n      improvements\n    } = feedbackData;\n    \n    const feedbackEntry = {\n      id: `feedback_${Date.now()}`,\n      timestamp: Date.now(),\n      generationId,\n      userId: userId || 'anonymous',\n      rating: rating || 0, // 1-5 scale\n      feedback: feedback || '',\n      categories: categories || [], // ['quality', 'speed', 'accuracy', etc.]\n      improvements: improvements || [], // suggested improvements\n      date: new Date().toISOString().split('T')[0]\n    };\n    \n    this.metrics.userFeedback.push(feedbackEntry);\n    await this.saveMetrics();\n    \n    return feedbackEntry.id;\n  }\n\n  /**\n   * Track system performance metrics\n   * @param {Object} performanceData - System performance data\n   */\n  async trackSystemPerformance(performanceData) {\n    const {\n      cpuUsage,\n      memoryUsage,\n      diskUsage,\n      activeJobs,\n      queueLength,\n      responseTime\n    } = performanceData;\n    \n    const performance = {\n      timestamp: Date.now(),\n      date: new Date().toISOString().split('T')[0],\n      cpu: cpuUsage || 0,\n      memory: memoryUsage || process.memoryUsage(),\n      disk: diskUsage || 0,\n      activeJobs: activeJobs || 0,\n      queueLength: queueLength || 0,\n      responseTime: responseTime || 0\n    };\n    \n    this.metrics.systemPerformance.push(performance);\n    \n    // Keep only last 1000 performance entries\n    if (this.metrics.systemPerformance.length > 1000) {\n      this.metrics.systemPerformance = this.metrics.systemPerformance.slice(-1000);\n    }\n    \n    await this.saveMetrics();\n  }\n\n  /**\n   * Update daily statistics\n   * @param {Object} generation - Generation data\n   */\n  updateDailyStats(generation) {\n    const date = generation.date;\n    \n    if (!this.metrics.dailyStats[date]) {\n      this.metrics.dailyStats[date] = {\n        totalGenerations: 0,\n        successfulGenerations: 0,\n        totalCost: 0,\n        totalDuration: 0,\n        averageQuality: 0,\n        qualityTiers: {},\n        models: {},\n        poses: {},\n        garmentTypes: {},\n        errors: {}\n      };\n    }\n    \n    const stats = this.metrics.dailyStats[date];\n    \n    stats.totalGenerations++;\n    if (generation.success) {\n      stats.successfulGenerations++;\n    }\n    \n    stats.totalCost += generation.cost;\n    stats.totalDuration += generation.duration;\n    \n    // Update averages\n    stats.averageQuality = (\n      (stats.averageQuality * (stats.totalGenerations - 1) + generation.finalQuality) / \n      stats.totalGenerations\n    );\n    \n    // Update breakdowns\n    stats.qualityTiers[generation.qualityTier] = (stats.qualityTiers[generation.qualityTier] || 0) + 1;\n    stats.models[generation.modelId] = (stats.models[generation.modelId] || 0) + 1;\n    stats.poses[generation.pose] = (stats.poses[generation.pose] || 0) + 1;\n    stats.garmentTypes[generation.garmentType] = (stats.garmentTypes[generation.garmentType] || 0) + 1;\n    \n    if (!generation.success && generation.errorType) {\n      stats.errors[generation.errorType] = (stats.errors[generation.errorType] || 0) + 1;\n    }\n  }\n\n  /**\n   * Update model performance metrics\n   * @param {Object} generation - Generation data\n   */\n  updateModelPerformance(generation) {\n    const modelId = generation.modelId;\n    \n    if (!this.metrics.modelPerformance[modelId]) {\n      this.metrics.modelPerformance[modelId] = {\n        totalGenerations: 0,\n        successfulGenerations: 0,\n        averageQuality: 0,\n        averageDuration: 0,\n        averageCost: 0,\n        poses: {},\n        qualityTiers: {},\n        consistencyScores: [],\n        lastUpdated: Date.now()\n      };\n    }\n    \n    const perf = this.metrics.modelPerformance[modelId];\n    \n    perf.totalGenerations++;\n    if (generation.success) {\n      perf.successfulGenerations++;\n    }\n    \n    // Update averages\n    perf.averageQuality = (\n      (perf.averageQuality * (perf.totalGenerations - 1) + generation.finalQuality) / \n      perf.totalGenerations\n    );\n    \n    perf.averageDuration = (\n      (perf.averageDuration * (perf.totalGenerations - 1) + generation.duration) / \n      perf.totalGenerations\n    );\n    \n    perf.averageCost = (\n      (perf.averageCost * (perf.totalGenerations - 1) + generation.cost) / \n      perf.totalGenerations\n    );\n    \n    // Update pose and quality tier breakdowns\n    perf.poses[generation.pose] = (perf.poses[generation.pose] || 0) + 1;\n    perf.qualityTiers[generation.qualityTier] = (perf.qualityTiers[generation.qualityTier] || 0) + 1;\n    \n    // Track consistency scores\n    if (generation.validation && generation.validation.consistency) {\n      perf.consistencyScores.push(generation.validation.consistency);\n      \n      // Keep only last 50 scores\n      if (perf.consistencyScores.length > 50) {\n        perf.consistencyScores = perf.consistencyScores.slice(-50);\n      }\n    }\n    \n    perf.lastUpdated = Date.now();\n  }\n\n  /**\n   * Update cost tracking\n   * @param {Object} generation - Generation data\n   */\n  updateCostTracking(generation) {\n    const date = generation.date;\n    const month = date.substring(0, 7); // YYYY-MM\n    \n    if (!this.metrics.costTracking[month]) {\n      this.metrics.costTracking[month] = {\n        totalCost: 0,\n        totalGenerations: 0,\n        costByTier: {},\n        costByModel: {},\n        dailyCosts: {}\n      };\n    }\n    \n    const tracking = this.metrics.costTracking[month];\n    \n    tracking.totalCost += generation.cost;\n    tracking.totalGenerations++;\n    \n    // Cost by tier\n    tracking.costByTier[generation.qualityTier] = \n      (tracking.costByTier[generation.qualityTier] || 0) + generation.cost;\n    \n    // Cost by model\n    tracking.costByModel[generation.modelId] = \n      (tracking.costByModel[generation.modelId] || 0) + generation.cost;\n    \n    // Daily costs\n    tracking.dailyCosts[date] = (tracking.dailyCosts[date] || 0) + generation.cost;\n  }\n\n  /**\n   * Get comprehensive analytics report\n   * @param {Object} options - Report options\n   * @returns {Object} Analytics report\n   */\n  getAnalyticsReport(options = {}) {\n    const {\n      startDate,\n      endDate,\n      modelId,\n      qualityTier,\n      includeDetails = false\n    } = options;\n    \n    // Filter generations based on criteria\n    let filteredGenerations = this.metrics.generations;\n    \n    if (startDate) {\n      filteredGenerations = filteredGenerations.filter(g => g.date >= startDate);\n    }\n    \n    if (endDate) {\n      filteredGenerations = filteredGenerations.filter(g => g.date <= endDate);\n    }\n    \n    if (modelId) {\n      filteredGenerations = filteredGenerations.filter(g => g.modelId === modelId);\n    }\n    \n    if (qualityTier) {\n      filteredGenerations = filteredGenerations.filter(g => g.qualityTier === qualityTier);\n    }\n    \n    // Calculate summary statistics\n    const totalGenerations = filteredGenerations.length;\n    const successfulGenerations = filteredGenerations.filter(g => g.success).length;\n    const successRate = totalGenerations > 0 ? successfulGenerations / totalGenerations : 0;\n    \n    const totalCost = filteredGenerations.reduce((sum, g) => sum + g.cost, 0);\n    const averageCost = totalGenerations > 0 ? totalCost / totalGenerations : 0;\n    \n    const totalDuration = filteredGenerations.reduce((sum, g) => sum + g.duration, 0);\n    const averageDuration = totalGenerations > 0 ? totalDuration / totalGenerations : 0;\n    \n    const qualityScores = filteredGenerations\n      .filter(g => g.finalQuality > 0)\n      .map(g => g.finalQuality);\n    const averageQuality = qualityScores.length > 0 ? \n      qualityScores.reduce((sum, q) => sum + q, 0) / qualityScores.length : 0;\n    \n    // Generate breakdowns\n    const breakdowns = {\n      byModel: this.generateBreakdown(filteredGenerations, 'modelId'),\n      byPose: this.generateBreakdown(filteredGenerations, 'pose'),\n      byQualityTier: this.generateBreakdown(filteredGenerations, 'qualityTier'),\n      byGarmentType: this.generateBreakdown(filteredGenerations, 'garmentType'),\n      byDate: this.generateDateBreakdown(filteredGenerations)\n    };\n    \n    // Calculate trends\n    const trends = this.calculateTrends(filteredGenerations);\n    \n    const report = {\n      summary: {\n        totalGenerations,\n        successfulGenerations,\n        successRate,\n        totalCost,\n        averageCost,\n        totalDuration,\n        averageDuration,\n        averageQuality\n      },\n      breakdowns,\n      trends,\n      period: {\n        startDate: startDate || (filteredGenerations.length > 0 ? filteredGenerations[0].date : null),\n        endDate: endDate || (filteredGenerations.length > 0 ? filteredGenerations[filteredGenerations.length - 1].date : null)\n      }\n    };\n    \n    if (includeDetails) {\n      report.details = {\n        generations: filteredGenerations.slice(-100), // Last 100 generations\n        userFeedback: this.getUserFeedbackSummary(filteredGenerations),\n        systemPerformance: this.getSystemPerformanceSummary()\n      };\n    }\n    \n    return report;\n  }\n\n  /**\n   * Generate breakdown by field\n   * @param {Array} generations - Filtered generations\n   * @param {string} field - Field to break down by\n   * @returns {Object} Breakdown data\n   */\n  generateBreakdown(generations, field) {\n    const breakdown = {};\n    \n    generations.forEach(g => {\n      const value = g[field] || 'unknown';\n      \n      if (!breakdown[value]) {\n        breakdown[value] = {\n          count: 0,\n          successCount: 0,\n          totalCost: 0,\n          totalDuration: 0,\n          qualitySum: 0,\n          qualityCount: 0\n        };\n      }\n      \n      const item = breakdown[value];\n      item.count++;\n      \n      if (g.success) {\n        item.successCount++;\n      }\n      \n      item.totalCost += g.cost;\n      item.totalDuration += g.duration;\n      \n      if (g.finalQuality > 0) {\n        item.qualitySum += g.finalQuality;\n        item.qualityCount++;\n      }\n    });\n    \n    // Calculate derived metrics\n    Object.values(breakdown).forEach(item => {\n      item.successRate = item.count > 0 ? item.successCount / item.count : 0;\n      item.averageCost = item.count > 0 ? item.totalCost / item.count : 0;\n      item.averageDuration = item.count > 0 ? item.totalDuration / item.count : 0;\n      item.averageQuality = item.qualityCount > 0 ? item.qualitySum / item.qualityCount : 0;\n    });\n    \n    return breakdown;\n  }\n\n  /**\n   * Generate date-based breakdown\n   * @param {Array} generations - Filtered generations\n   * @returns {Object} Date breakdown\n   */\n  generateDateBreakdown(generations) {\n    const breakdown = {};\n    \n    generations.forEach(g => {\n      const date = g.date;\n      \n      if (!breakdown[date]) {\n        breakdown[date] = {\n          count: 0,\n          successCount: 0,\n          totalCost: 0,\n          averageQuality: 0\n        };\n      }\n      \n      breakdown[date].count++;\n      if (g.success) {\n        breakdown[date].successCount++;\n      }\n      breakdown[date].totalCost += g.cost;\n      \n      // Update average quality\n      const prevAvg = breakdown[date].averageQuality;\n      const count = breakdown[date].count;\n      breakdown[date].averageQuality = (prevAvg * (count - 1) + g.finalQuality) / count;\n    });\n    \n    return breakdown;\n  }\n\n  /**\n   * Calculate performance trends\n   * @param {Array} generations - Filtered generations\n   * @returns {Object} Trend data\n   */\n  calculateTrends(generations) {\n    if (generations.length < 10) {\n      return { insufficient_data: true };\n    }\n    \n    // Sort by timestamp\n    const sorted = [...generations].sort((a, b) => a.timestamp - b.timestamp);\n    \n    // Calculate moving averages\n    const windowSize = Math.min(10, Math.floor(sorted.length / 5));\n    const trends = {\n      successRate: this.calculateMovingAverage(sorted, 'success', windowSize),\n      quality: this.calculateMovingAverage(sorted, 'finalQuality', windowSize),\n      cost: this.calculateMovingAverage(sorted, 'cost', windowSize),\n      duration: this.calculateMovingAverage(sorted, 'duration', windowSize)\n    };\n    \n    return trends;\n  }\n\n  /**\n   * Calculate moving average for a metric\n   * @param {Array} data - Sorted data array\n   * @param {string} field - Field to calculate average for\n   * @param {number} windowSize - Window size for moving average\n   * @returns {Array} Moving average data points\n   */\n  calculateMovingAverage(data, field, windowSize) {\n    const result = [];\n    \n    for (let i = windowSize - 1; i < data.length; i++) {\n      const window = data.slice(i - windowSize + 1, i + 1);\n      let sum = 0;\n      let count = 0;\n      \n      window.forEach(item => {\n        if (field === 'success') {\n          sum += item[field] ? 1 : 0;\n          count++;\n        } else if (item[field] !== undefined && item[field] > 0) {\n          sum += item[field];\n          count++;\n        }\n      });\n      \n      result.push({\n        timestamp: data[i].timestamp,\n        value: count > 0 ? sum / count : 0\n      });\n    }\n    \n    return result;\n  }\n\n  /**\n   * Get user feedback summary\n   * @param {Array} generations - Filtered generations\n   * @returns {Object} Feedback summary\n   */\n  getUserFeedbackSummary(generations) {\n    const generationIds = new Set(generations.map(g => g.id));\n    const relevantFeedback = this.metrics.userFeedback.filter(f => \n      generationIds.has(f.generationId)\n    );\n    \n    if (relevantFeedback.length === 0) {\n      return { count: 0 };\n    }\n    \n    const totalRating = relevantFeedback.reduce((sum, f) => sum + f.rating, 0);\n    const averageRating = totalRating / relevantFeedback.length;\n    \n    const categoryBreakdown = {};\n    relevantFeedback.forEach(f => {\n      f.categories.forEach(cat => {\n        categoryBreakdown[cat] = (categoryBreakdown[cat] || 0) + 1;\n      });\n    });\n    \n    return {\n      count: relevantFeedback.length,\n      averageRating,\n      categoryBreakdown,\n      recentFeedback: relevantFeedback.slice(-10)\n    };\n  }\n\n  /**\n   * Get system performance summary\n   * @returns {Object} Performance summary\n   */\n  getSystemPerformanceSummary() {\n    const recent = this.metrics.systemPerformance.slice(-100);\n    \n    if (recent.length === 0) {\n      return { count: 0 };\n    }\n    \n    const avgCpu = recent.reduce((sum, p) => sum + p.cpu, 0) / recent.length;\n    const avgMemory = recent.reduce((sum, p) => sum + (p.memory.heapUsed || 0), 0) / recent.length;\n    const avgResponseTime = recent.reduce((sum, p) => sum + p.responseTime, 0) / recent.length;\n    \n    return {\n      count: recent.length,\n      averageCpu: avgCpu,\n      averageMemory: avgMemory,\n      averageResponseTime: avgResponseTime,\n      latest: recent[recent.length - 1]\n    };\n  }\n\n  /**\n   * Get cost optimization recommendations\n   * @returns {Array} Cost optimization recommendations\n   */\n  getCostOptimizationRecommendations() {\n    const recommendations = [];\n    const recentGenerations = this.metrics.generations.slice(-100);\n    \n    if (recentGenerations.length < 10) {\n      return ['Insufficient data for cost optimization recommendations'];\n    }\n    \n    // Analyze cost by quality tier\n    const tierBreakdown = this.generateBreakdown(recentGenerations, 'qualityTier');\n    \n    Object.entries(tierBreakdown).forEach(([tier, data]) => {\n      if (data.successRate < 0.7 && data.averageCost > 0.15) {\n        recommendations.push(\n          `Consider reducing usage of ${tier} tier (${(data.successRate * 100).toFixed(1)}% success rate, $${data.averageCost.toFixed(3)} avg cost)`\n        );\n      }\n    });\n    \n    // Analyze retry patterns\n    const highRetryGenerations = recentGenerations.filter(g => g.retryCount > 2);\n    if (highRetryGenerations.length > recentGenerations.length * 0.2) {\n      recommendations.push(\n        'High retry rate detected. Consider adjusting quality thresholds or parameters to reduce costs.'\n      );\n    }\n    \n    // Analyze model performance\n    const modelBreakdown = this.generateBreakdown(recentGenerations, 'modelId');\n    Object.entries(modelBreakdown).forEach(([model, data]) => {\n      if (data.successRate < 0.6) {\n        recommendations.push(\n          `Model ${model} has low success rate (${(data.successRate * 100).toFixed(1)}%). Consider parameter optimization.`\n        );\n      }\n    });\n    \n    return recommendations.length > 0 ? recommendations : ['No specific cost optimization recommendations at this time'];\n  }\n\n  /**\n   * Load metrics from file\n   */\n  async loadMetrics() {\n    try {\n      const data = await fs.readFile(this.metricsFile, 'utf8');\n      this.metrics = { ...this.metrics, ...JSON.parse(data) };\n    } catch (error) {\n      // File doesn't exist or is invalid, start with empty metrics\n      console.log('Starting with empty metrics (file not found or invalid)');\n    }\n  }\n\n  /**\n   * Save metrics to file\n   */\n  async saveMetrics() {\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(this.metricsFile);\n      await fs.mkdir(dir, { recursive: true });\n      \n      await fs.writeFile(this.metricsFile, JSON.stringify(this.metrics, null, 2));\n    } catch (error) {\n      console.error('Failed to save metrics:', error);\n    }\n  }\n\n  /**\n   * Start periodic cleanup of old data\n   */\n  startPeriodicCleanup() {\n    // Run cleanup every 24 hours\n    setInterval(() => {\n      this.cleanupOldData();\n    }, 24 * 60 * 60 * 1000);\n  }\n\n  /**\n   * Clean up old data beyond retention period\n   */\n  async cleanupOldData() {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - this.retentionDays);\n    const cutoffTimestamp = cutoffDate.getTime();\n    \n    // Clean up generations\n    this.metrics.generations = this.metrics.generations.filter(\n      g => g.timestamp > cutoffTimestamp\n    );\n    \n    // Clean up user feedback\n    this.metrics.userFeedback = this.metrics.userFeedback.filter(\n      f => f.timestamp > cutoffTimestamp\n    );\n    \n    // Clean up daily stats\n    const cutoffDateStr = cutoffDate.toISOString().split('T')[0];\n    Object.keys(this.metrics.dailyStats).forEach(date => {\n      if (date < cutoffDateStr) {\n        delete this.metrics.dailyStats[date];\n      }\n    });\n    \n    await this.saveMetrics();\n  }\n\n  /**\n   * Get metrics statistics\n   * @returns {Object} Metrics statistics\n   */\n  getStatistics() {\n    return {\n      totalGenerations: this.metrics.generations.length,\n      totalFeedback: this.metrics.userFeedback.length,\n      totalDailyStats: Object.keys(this.metrics.dailyStats).length,\n      totalModelPerformance: Object.keys(this.metrics.modelPerformance).length,\n      retentionDays: this.retentionDays,\n      version: '1.0.0'\n    };\n  }\n}\n\nmodule.exports = MetricsTracking;