const fs = require('fs').promises;\nconst path = require('path');\n\n/**\n * ParameterOptimization - Automatic parameter tuning based on validation results\n * Implements learning algorithms to optimize generation parameters over time\n */\nclass ParameterOptimization {\n  constructor() {\n    this.optimizationHistory = [];\n    this.parameterRanges = {\n      modelReferenceStrength: { min: 0.5, max: 1.0, step: 0.05 },\n      poseGuidanceScale: { min: 0.5, max: 2.0, step: 0.1 },\n      colorMatchingWeight: { min: 0.4, max: 1.0, step: 0.05 },\n      styleTransferWeight: { min: 0.3, max: 1.0, step: 0.05 },\n      brandingEnhancementWeight: { min: 0.5, max: 1.0, step: 0.05 },\n      noiseLevel: { min: 0.1, max: 0.8, step: 0.05 },\n      guidanceScale: { min: 5.0, max: 20.0, step: 0.5 },\n      steps: { min: 20, max: 100, step: 5 }\n    };\n    \n    this.baselineParameters = {\n      standard: {\n        modelReferenceStrength: 0.8,\n        poseGuidanceScale: 1.0,\n        colorMatchingWeight: 0.7,\n        styleTransferWeight: 0.6,\n        brandingEnhancementWeight: 0.8,\n        noiseLevel: 0.3,\n        guidanceScale: 7.5,\n        steps: 30\n      },\n      premium: {\n        modelReferenceStrength: 0.85,\n        poseGuidanceScale: 1.2,\n        colorMatchingWeight: 0.8,\n        styleTransferWeight: 0.7,\n        brandingEnhancementWeight: 0.85,\n        noiseLevel: 0.25,\n        guidanceScale: 10.0,\n        steps: 50\n      },\n      ultra: {\n        modelReferenceStrength: 0.9,\n        poseGuidanceScale: 1.5,\n        colorMatchingWeight: 0.9,\n        styleTransferWeight: 0.8,\n        brandingEnhancementWeight: 0.9,\n        noiseLevel: 0.2,\n        guidanceScale: 12.5,\n        steps: 75\n      }\n    };\n    \n    this.learningRate = 0.1;\n    this.explorationRate = 0.2;\n    this.historyFile = path.join(__dirname, '../../data/optimization_history.json');\n    \n    // Load existing history\n    this.loadOptimizationHistory();\n  }\n\n  /**\n   * Optimize parameters based on validation results and context\n   * @param {Object} context - Generation context\n   * @param {Object} validationResult - Validation results\n   * @param {Object} currentParameters - Current generation parameters\n   * @returns {Object} Optimized parameters\n   */\n  async optimizeParameters(context, validationResult, currentParameters) {\n    const { modelId, pose, garmentType, qualityTier, productAnalysis } = context;\n    \n    // Record current attempt\n    const attempt = {\n      timestamp: Date.now(),\n      context: { modelId, pose, garmentType, qualityTier },\n      parameters: { ...currentParameters },\n      validation: {\n        overallQuality: validationResult.overallQuality,\n        consistency: validationResult.consistency?.overallScore || 0,\n        accuracy: validationResult.accuracy?.overallScore || 0,\n        passes: validationResult.passes\n      }\n    };\n    \n    this.optimizationHistory.push(attempt);\n    \n    // Get baseline parameters for quality tier\n    const baseline = this.baselineParameters[qualityTier] || this.baselineParameters.standard;\n    \n    // Apply context-specific optimizations\n    let optimizedParams = { ...baseline };\n    \n    // Model-specific optimizations\n    optimizedParams = this.applyModelOptimizations(optimizedParams, modelId, validationResult);\n    \n    // Pose-specific optimizations\n    optimizedParams = this.applyPoseOptimizations(optimizedParams, pose, validationResult);\n    \n    // Garment-specific optimizations\n    optimizedParams = this.applyGarmentOptimizations(optimizedParams, garmentType, validationResult);\n    \n    // Branding-specific optimizations\n    if (productAnalysis?.branding) {\n      optimizedParams = this.applyBrandingOptimizations(optimizedParams, productAnalysis.branding, validationResult);\n    }\n    \n    // Apply learning-based optimizations\n    optimizedParams = this.applyLearningOptimizations(optimizedParams, context, validationResult);\n    \n    // Apply exploration for continuous improvement\n    if (Math.random() < this.explorationRate) {\n      optimizedParams = this.applyExploration(optimizedParams);\n    }\n    \n    // Ensure parameters are within valid ranges\n    optimizedParams = this.clampParameters(optimizedParams);\n    \n    // Save optimization history\n    await this.saveOptimizationHistory();\n    \n    return optimizedParams;\n  }\n\n  /**\n   * Apply model-specific parameter optimizations\n   * @param {Object} params - Current parameters\n   * @param {string} modelId - Model identifier\n   * @param {Object} validationResult - Validation results\n   * @returns {Object} Optimized parameters\n   */\n  applyModelOptimizations(params, modelId, validationResult) {\n    const optimized = { ...params };\n    \n    // Model-specific adjustments based on historical performance\n    const modelHistory = this.getModelHistory(modelId);\n    \n    if (modelHistory.length > 5) {\n      const avgConsistency = modelHistory.reduce((sum, h) => sum + h.validation.consistency, 0) / modelHistory.length;\n      \n      if (avgConsistency < 0.7) {\n        // Increase model reference strength for better consistency\n        optimized.modelReferenceStrength = Math.min(1.0, optimized.modelReferenceStrength + 0.1);\n      }\n    }\n    \n    // Current validation-based adjustments\n    if (validationResult.consistency && validationResult.consistency.faceConsistency < 0.7) {\n      optimized.modelReferenceStrength = Math.min(1.0, optimized.modelReferenceStrength + 0.05);\n    }\n    \n    return optimized;\n  }\n\n  /**\n   * Apply pose-specific parameter optimizations\n   * @param {Object} params - Current parameters\n   * @param {string} pose - Target pose\n   * @param {Object} validationResult - Validation results\n   * @returns {Object} Optimized parameters\n   */\n  applyPoseOptimizations(params, pose, validationResult) {\n    const optimized = { ...params };\n    \n    // Pose-specific adjustments\n    const poseComplexity = {\n      'Arms Crossed': 0.8,\n      'Contrapposto': 1.0,\n      'Clasping Hands': 0.9,\n      'Hands On Chest': 0.7,\n      'Holding One Arm': 0.8,\n      'Hands in Pockets': 0.6\n    };\n    \n    const complexity = poseComplexity[pose] || 0.8;\n    \n    // Adjust pose guidance based on complexity\n    optimized.poseGuidanceScale = optimized.poseGuidanceScale * complexity;\n    \n    // Current validation-based adjustments\n    if (validationResult.consistency && validationResult.consistency.poseAccuracy < 0.6) {\n      optimized.poseGuidanceScale = Math.min(2.0, optimized.poseGuidanceScale + 0.2);\n    }\n    \n    return optimized;\n  }\n\n  /**\n   * Apply garment-specific parameter optimizations\n   * @param {Object} params - Current parameters\n   * @param {string} garmentType - Type of garment\n   * @param {Object} validationResult - Validation results\n   * @returns {Object} Optimized parameters\n   */\n  applyGarmentOptimizations(params, garmentType, validationResult) {\n    const optimized = { ...params };\n    \n    // Garment-specific parameter adjustments\n    const garmentSettings = {\n      'tshirt': {\n        styleTransferWeight: 0.6,\n        colorMatchingWeight: 0.8\n      },\n      'hoodie': {\n        styleTransferWeight: 0.8,\n        colorMatchingWeight: 0.7\n      },\n      'polo': {\n        styleTransferWeight: 0.7,\n        colorMatchingWeight: 0.8\n      },\n      'dress': {\n        styleTransferWeight: 0.9,\n        colorMatchingWeight: 0.7\n      },\n      'jacket': {\n        styleTransferWeight: 0.9,\n        colorMatchingWeight: 0.6\n      }\n    };\n    \n    const garmentConfig = garmentSettings[garmentType];\n    if (garmentConfig) {\n      Object.assign(optimized, garmentConfig);\n    }\n    \n    // Validation-based adjustments\n    if (validationResult.accuracy) {\n      if (validationResult.accuracy.styleAccuracy < 0.6) {\n        optimized.styleTransferWeight = Math.min(1.0, optimized.styleTransferWeight + 0.1);\n      }\n      \n      if (validationResult.accuracy.colorAccuracy < 0.7) {\n        optimized.colorMatchingWeight = Math.min(1.0, optimized.colorMatchingWeight + 0.1);\n      }\n    }\n    \n    return optimized;\n  }\n\n  /**\n   * Apply branding-specific parameter optimizations\n   * @param {Object} params - Current parameters\n   * @param {Object} branding - Branding information\n   * @param {Object} validationResult - Validation results\n   * @returns {Object} Optimized parameters\n   */\n  applyBrandingOptimizations(params, branding, validationResult) {\n    const optimized = { ...params };\n    \n    // Adjust branding enhancement based on type\n    if (branding.hasEmbroidery) {\n      optimized.brandingEnhancementWeight = Math.max(0.8, optimized.brandingEnhancementWeight);\n    } else if (branding.hasScreenPrint) {\n      optimized.brandingEnhancementWeight = Math.max(0.7, optimized.brandingEnhancementWeight);\n    }\n    \n    // Validation-based adjustments\n    if (validationResult.accuracy && validationResult.accuracy.brandingAccuracy < 0.8) {\n      optimized.brandingEnhancementWeight = Math.min(1.0, optimized.brandingEnhancementWeight + 0.1);\n    }\n    \n    return optimized;\n  }\n\n  /**\n   * Apply learning-based optimizations from historical data\n   * @param {Object} params - Current parameters\n   * @param {Object} context - Generation context\n   * @param {Object} validationResult - Validation results\n   * @returns {Object} Optimized parameters\n   */\n  applyLearningOptimizations(params, context, validationResult) {\n    const optimized = { ...params };\n    \n    // Find similar historical contexts\n    const similarAttempts = this.findSimilarAttempts(context);\n    \n    if (similarAttempts.length < 3) {\n      return optimized; // Not enough data for learning\n    }\n    \n    // Analyze successful attempts\n    const successfulAttempts = similarAttempts.filter(a => a.validation.passes);\n    \n    if (successfulAttempts.length > 0) {\n      // Calculate average parameters from successful attempts\n      const avgParams = this.calculateAverageParameters(successfulAttempts);\n      \n      // Apply learning rate to move towards successful parameters\n      Object.keys(avgParams).forEach(key => {\n        if (optimized[key] !== undefined) {\n          const diff = avgParams[key] - optimized[key];\n          optimized[key] += diff * this.learningRate;\n        }\n      });\n    }\n    \n    // Analyze parameter correlations with quality scores\n    const correlations = this.calculateParameterCorrelations(similarAttempts);\n    \n    // Apply correlation-based adjustments\n    Object.entries(correlations).forEach(([param, correlation]) => {\n      if (Math.abs(correlation) > 0.3 && optimized[param] !== undefined) {\n        const adjustment = correlation > 0 ? 0.05 : -0.05;\n        optimized[param] += adjustment;\n      }\n    });\n    \n    return optimized;\n  }\n\n  /**\n   * Apply exploration to parameters for continuous improvement\n   * @param {Object} params - Current parameters\n   * @returns {Object} Parameters with exploration\n   */\n  applyExploration(params) {\n    const explored = { ...params };\n    \n    // Randomly adjust a few parameters within small ranges\n    const paramsToExplore = Object.keys(this.parameterRanges);\n    const numToExplore = Math.floor(Math.random() * 3) + 1;\n    \n    for (let i = 0; i < numToExplore; i++) {\n      const paramName = paramsToExplore[Math.floor(Math.random() * paramsToExplore.length)];\n      const range = this.parameterRanges[paramName];\n      \n      if (explored[paramName] !== undefined) {\n        const adjustment = (Math.random() - 0.5) * range.step * 2;\n        explored[paramName] += adjustment;\n      }\n    }\n    \n    return explored;\n  }\n\n  /**\n   * Clamp parameters to valid ranges\n   * @param {Object} params - Parameters to clamp\n   * @returns {Object} Clamped parameters\n   */\n  clampParameters(params) {\n    const clamped = { ...params };\n    \n    Object.entries(this.parameterRanges).forEach(([param, range]) => {\n      if (clamped[param] !== undefined) {\n        clamped[param] = Math.max(range.min, Math.min(range.max, clamped[param]));\n        \n        // Round to step precision\n        clamped[param] = Math.round(clamped[param] / range.step) * range.step;\n      }\n    });\n    \n    return clamped;\n  }\n\n  /**\n   * Find similar attempts in history\n   * @param {Object} context - Current context\n   * @returns {Array} Similar attempts\n   */\n  findSimilarAttempts(context) {\n    return this.optimizationHistory.filter(attempt => {\n      const ctx = attempt.context;\n      return ctx.modelId === context.modelId &&\n             ctx.pose === context.pose &&\n             ctx.qualityTier === context.qualityTier &&\n             (ctx.garmentType === context.garmentType || !ctx.garmentType || !context.garmentType);\n    });\n  }\n\n  /**\n   * Get model-specific history\n   * @param {string} modelId - Model identifier\n   * @returns {Array} Model history\n   */\n  getModelHistory(modelId) {\n    return this.optimizationHistory.filter(attempt => \n      attempt.context.modelId === modelId\n    ).slice(-20); // Last 20 attempts\n  }\n\n  /**\n   * Calculate average parameters from attempts\n   * @param {Array} attempts - List of attempts\n   * @returns {Object} Average parameters\n   */\n  calculateAverageParameters(attempts) {\n    if (attempts.length === 0) return {};\n    \n    const avgParams = {};\n    const paramKeys = Object.keys(attempts[0].parameters);\n    \n    paramKeys.forEach(key => {\n      const values = attempts.map(a => a.parameters[key]).filter(v => v !== undefined);\n      if (values.length > 0) {\n        avgParams[key] = values.reduce((sum, val) => sum + val, 0) / values.length;\n      }\n    });\n    \n    return avgParams;\n  }\n\n  /**\n   * Calculate parameter correlations with quality scores\n   * @param {Array} attempts - List of attempts\n   * @returns {Object} Parameter correlations\n   */\n  calculateParameterCorrelations(attempts) {\n    if (attempts.length < 5) return {};\n    \n    const correlations = {};\n    const paramKeys = Object.keys(this.parameterRanges);\n    \n    paramKeys.forEach(param => {\n      const paramValues = [];\n      const qualityValues = [];\n      \n      attempts.forEach(attempt => {\n        if (attempt.parameters[param] !== undefined) {\n          paramValues.push(attempt.parameters[param]);\n          qualityValues.push(attempt.validation.overallQuality);\n        }\n      });\n      \n      if (paramValues.length >= 5) {\n        correlations[param] = this.calculateCorrelation(paramValues, qualityValues);\n      }\n    });\n    \n    return correlations;\n  }\n\n  /**\n   * Calculate Pearson correlation coefficient\n   * @param {Array} x - X values\n   * @param {Array} y - Y values\n   * @returns {number} Correlation coefficient\n   */\n  calculateCorrelation(x, y) {\n    const n = x.length;\n    if (n === 0) return 0;\n    \n    const sumX = x.reduce((a, b) => a + b, 0);\n    const sumY = y.reduce((a, b) => a + b, 0);\n    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);\n    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);\n    const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);\n    \n    const numerator = n * sumXY - sumX * sumY;\n    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n    \n    return denominator === 0 ? 0 : numerator / denominator;\n  }\n\n  /**\n   * Get optimization recommendations based on current performance\n   * @param {Object} context - Generation context\n   * @returns {Array} Optimization recommendations\n   */\n  getOptimizationRecommendations(context) {\n    const recommendations = [];\n    const similarAttempts = this.findSimilarAttempts(context);\n    \n    if (similarAttempts.length === 0) {\n      recommendations.push('No historical data available for this configuration');\n      return recommendations;\n    }\n    \n    const successRate = similarAttempts.filter(a => a.validation.passes).length / similarAttempts.length;\n    const avgQuality = similarAttempts.reduce((sum, a) => sum + a.validation.overallQuality, 0) / similarAttempts.length;\n    \n    if (successRate < 0.5) {\n      recommendations.push('Low success rate detected. Consider adjusting quality tier or parameters.');\n    }\n    \n    if (avgQuality < 0.6) {\n      recommendations.push('Average quality is below threshold. Recommend parameter optimization.');\n    }\n    \n    // Analyze specific issues\n    const consistencyIssues = similarAttempts.filter(a => a.validation.consistency < 0.6).length;\n    const accuracyIssues = similarAttempts.filter(a => a.validation.accuracy < 0.6).length;\n    \n    if (consistencyIssues > similarAttempts.length * 0.3) {\n      recommendations.push('Frequent consistency issues. Consider increasing model reference strength.');\n    }\n    \n    if (accuracyIssues > similarAttempts.length * 0.3) {\n      recommendations.push('Frequent accuracy issues. Consider adjusting color matching and style transfer weights.');\n    }\n    \n    return recommendations;\n  }\n\n  /**\n   * Load optimization history from file\n   */\n  async loadOptimizationHistory() {\n    try {\n      const data = await fs.readFile(this.historyFile, 'utf8');\n      this.optimizationHistory = JSON.parse(data);\n    } catch (error) {\n      // File doesn't exist or is invalid, start with empty history\n      this.optimizationHistory = [];\n    }\n  }\n\n  /**\n   * Save optimization history to file\n   */\n  async saveOptimizationHistory() {\n    try {\n      // Keep only last 1000 entries to prevent file from growing too large\n      const historyToSave = this.optimizationHistory.slice(-1000);\n      \n      // Ensure directory exists\n      const dir = path.dirname(this.historyFile);\n      await fs.mkdir(dir, { recursive: true });\n      \n      await fs.writeFile(this.historyFile, JSON.stringify(historyToSave, null, 2));\n    } catch (error) {\n      console.error('Failed to save optimization history:', error);\n    }\n  }\n\n  /**\n   * Get optimization statistics\n   * @returns {Object} Optimization statistics\n   */\n  getStatistics() {\n    const totalAttempts = this.optimizationHistory.length;\n    const successfulAttempts = this.optimizationHistory.filter(a => a.validation.passes).length;\n    const avgQuality = totalAttempts > 0 ? \n      this.optimizationHistory.reduce((sum, a) => sum + a.validation.overallQuality, 0) / totalAttempts : 0;\n    \n    return {\n      totalAttempts,\n      successfulAttempts,\n      successRate: totalAttempts > 0 ? successfulAttempts / totalAttempts : 0,\n      averageQuality: avgQuality,\n      learningRate: this.learningRate,\n      explorationRate: this.explorationRate,\n      version: '1.0.0'\n    };\n  }\n\n  /**\n   * Reset optimization history\n   */\n  async resetHistory() {\n    this.optimizationHistory = [];\n    await this.saveOptimizationHistory();\n  }\n}\n\nmodule.exports = ParameterOptimization;